#!/bin/sh
#
# Description:  Manages a cluster service for PostgreSQL
#               streaming replication clusters
#
# Author:       Bernd Helmle (bernd.helmle@credativ.de)

# OCF parameters:
#
#     OCF_RESKEY_pgpidfile         - Path to the local PostgreSQL PID file
#     OCF_RESKEY_primary_db        - PostgreSQL primary database to connect to for CLONING
#     OCF_RESKEY_primary_host      - PostgreSQL primary ip address to connect for CLONING
#     OCF_RESKEY_primary_port      - PostgreSQL primary port to connect to for CLONING
#     OCF_RESKEY_primary_user      - PostgreSQL primary user to connect as for CLONING
#     OCF_RESKEY_pgdata            - Path to the local PGDATA directory
#     OCF_RESKEY_rsync_user        - Rsync user name to use for repmgr during CLONING
#     OCF_RESKEY_resowner          - Resource owner (default 'postgres')
#     OCF_RESKEY_wal_keep_segments - Forced number of WALs to keep (GUC wal_keep_segments)
#     OCF_RESKEY_repmgr_config     - Full path to the repmgr configuration file
#     OCF_RESKEY_pgctl             - Full path to pg_ctl binary of the local PostgreSQL instance
#     OCF_RESKEY_repmgrbindir      - Full path to repmgr binary. This is also where we assume
#                                    where the repmgrd binary resides.
#     OCF_RESKEY_psqlbin           - psql binary location (full path)

: ${OCF_FUNCTIONS_DIR=${OCF_ROOT}/resource.d/heartbeat}
. ${OCF_FUNCTIONS_DIR}/.ocf-shellfuncs

: ${OCF_RESKEY_repmgr_conf="/etc/repmgr.conf"}
: ${OCF_RESKEY_stop_escalate=30}

##
## Internal resource parameters
##

PIDFILE="${OCF_RESKEY_pgdata}/postmaster.pid"
BACKUPLABEL="${OCF_RESKEY_pgdata}/backup_label"
ATTRD_UPDATER="${HA_SBIN_DIR}/attrd_updater -q -d 0"
PGREPMGR_STATUS_NAME="pgrepmgr-status"
CLONE_LOCK="${OCF_RESKEY_tmpdir}/PGSQL.${OCF_RESKEY_primary_host}.${OCF_RESKEY_primary_port}.clone"
PSQLCMD="/usr/bin/psql -v ON_ERROR_STOP=1 -qXtnAc"

##
## Internal status codes
##
PGREPMGR_STATUS_IS_PRIMARY=0
PGREPMGR_STATUS_IS_HOTSTANDBY=1

usage() {

    cat<<EOF

	usage: $0 start|stop|status|monitor|meta-data|validate-all|methods

	$0 manages a PostgreSQL Server as an HA resource.

         The 'start' operation starts the PostgreSQL server.
         The 'stop' operation stops the PostgreSQL server.
         The 'status' operation reports whether the PostgreSQL is up.
         The 'monitor' operation reports whether the PostgreSQL is running.
         The 'promote' operation delegates primary role to the PostgreSQL instance
         The 'demote' operation makes a PostgreSQL instance to a standby
         The 'validate-all' operation reports whether the parameters are valid.
         The 'methods' operation reports on the methods $0 supports.

EOF
  return $OCF_ERR_ARGS
}

meta_data() {
cat <<EOF
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="pgrepmgr">
<version>1.0</version>

<longdesc lang="en">
Resource script for PostgreSQL Streaming Replication Clusters.
</longdesc>
<shortdesc lang="en">Manages a PostgreSQL Streaming Replication Cluster</shortdesc>

<actions>
<action name="start" timeout="20" />
<action name="stop"  timeout="20" />
<action name="reload"  timeout="20" />
<action name="promote" timeout="40" />
<action name="demote" timeout="43200" />
<action name="meta-data" timeout="5" />
<action name="monitor" timeout="40" />
</actions>

<parameters>

<parameter name="psqlbin" unique="0" required="0">
<longdesc lang="en">
Location (full path) of the psqbin binary.
</longdesc>
<shortdesc lang="en">psqlbin</shortdesc>
<content type="string"/>
</parameter>

<parameter name="repmgrbindir" unique="0" required="0">
<longdesc lang="en">
Location (full path) of the repmgr and repmgrd binaries. This specifies
the directory where the binaries are installed, in opposite to psqlbin
</longdesc>
<shortdesc lang="en">repmgrbindir</shortdesc>
<content type="string"/>
</parameter>

<parameter name="pgctl" unique="0" required="0">
<longdesc lang="en">
Full path to pg_ctl binary of the local PostgreSQL instance.
<shortdesc lang="en">pgctl</shortdesc>
<content type="string"/>
</longdesc>

</parameter>

<parameter name="pgpidfile" unique="0" required="1">
<longdesc lang="en">
PID file of the local PostgreSQL instance
</longdesc>
<shortdesc lang="en">pgpidfile</shortdesc>
<content type="string"/>
</parameter>

<parameter name="primary_db" unique="0" required="1">
<longdesc lang="en">
Databasename of the primary node to connect to
</longdesc>
<shortdesc lang="en">primary_db<shortdesc>
<content type ="string"/>
</parameter>

<parameter name ="primary_host" unique="0" required="1">
<longdesc lang="en">
Hostname/IP of the primary node to connect to
</longdesc>
<shortdesc>primary_host</shortdesc>
<content type="string"/>
</parameter>

<parameter name ="primary_port" unique="0" required="1">
<longdesc lang="en">
Port number of the primary node to connect to
</longdesc>
<shortdesc>primary_port</shortdesc>
<content type="integer"/>
</parameter>

<parameter name ="primary_user" unique="0" required="1">
<longdesc lang="en">
Username of the primary node to connect as
</longdesc>
<shortdesc>primary_user</shortdesc>
<content type="string"/>
</parameter>

<parameter name ="pgdata" unique="0" required="1">
<longdesc lang="en">
Local PGDATA directory (local PostgreSQL instance)
</longdesc>
<shortdesc>pgdata</shortdesc>
<content type="string"/>
</parameter>

<parameter name ="rsync_user" unique="0" required="1">
<longdesc lang="en">
rsync user to use for cloning a remote instance
</longdesc>
<shortdesc>rsync_user</shortdesc>
<content type="string"/>
</parameter>

<parameter name ="wal_keep_segments" unique="0" required="1">
<longdesc lang="en">
Maximum number of XLOG segments to keep (instructs GUC 
wal_keep_segments of the primary node).
</longdesc>
<shortdesc>wal_keep_segments</shortdesc>
<content type="integer"/>
</parameter>

<parameter name ="repmgr_config" unique="0" required="0">
<longdesc lang="en">
repmgr configuration file (default '/etc/repmgr.conf')
</longdesc>
<shortdesc>repmgr_config</shortdesc>
<content type="string"/>
</parameter>

<parameter name ="resource_owner" unique="0" required="0" default="postgres">
<longdesc lang="en">
Resource owner (system shell user) of this agent (default 'postgres')
</longdesc>
<shortdesc>resource_owner</shortdesc>
<content type="string"/>
</parameter>

</parameters>

</resource-agent>
EOF

exit $OCF_SUCCESS
}

runasowner() {
    su $OCF_RESKEY_resowner -c "$*"
}

pgrepmgr_methods() {
    cat <<EOF
	start
	stop
	status
	demote
	promote
	monitor
	notify
	methods
	meta-data
	validate-all
EOF
    return $OCF_SUCCESS
}

pgrepmgr_start() {

    return pgrepmgr_status

}

pgrepmgr_stop() {

    ## If the current node is a standby, shut down
    ## repmgrd

    return $OCF_SUCCESS

}

pgrepmgr_status() {
     if [ -f $PIDFILE ]
     then
         PID=`head -n 1 $PIDFILE`
         kill -0 $PID >/dev/null 2>&1 && fuser $OCF_RESKEY_pgdata 2>&1 | grep $PID >/dev/null 2>&1
         return $?
     fi

     # No PID file
     return $OCF_NOT_RUNNING
}

##
## Checks wether the current PostgreSQL node is running
## as a primary or hot standby instance
##
pgrepmgr_get_replication_status() {

    if [[ $(runasowner "$PSQLCMD 'SELECT pg_is_in_recovery();'") = 'f' ]]; then
	return $PGREPMGR_STATUS_IS_HOT_STANDBY
    fi

    return $PGREPMGR_STATUS_IS_PRIMARY

}

## Monitor PostgreSQL instance. Since repmgr is depending on a running
## PostgreSQL instance, make sure it is running
pgrepmgr_monitor() {

    ## We need to be careful with monitor probes against this resource

    if ! ocf_is_probe; then

	ocf_log info "$RESOURCE monitor: no OCF probe"

	if ! pgrepmgr_status; then
	    ocf_log warn "$RESOURCE monitor: PostgreSQL not running"
	    pgrepmgr_cib_status "STOP:not running"
	    return $OCF_NOT_RUNNING
	fi

    else

	## check wether any action is in progress
	ocf_log info "OCF probe"
	
	## While this RA is running it might occur that syncing during
	## a demote phase could have a very long duration. Check for a
	## in-progress clone phase.
	if [ -f $CLONE_LOCK ]; then
	    $ATTRD_UPDATER -n $PGREPMGR_STATUS_NAME -v "STOP:waiting for promote"
	    return $OCF_SUCCESS
	fi

	if ! pgrepmgr_status; then
	    ocf_log warn "$RESOURCE monitor: PostgreSQL not running"
	    pgrepmgr_cib_status "STOP:not running"
	    return $OCF_NOT_RUNNING
	fi

	ocf_log info "$RESOURCE monitor: PostgreSQL running"

	##
	## Not CLONE_LOCK file found, what role is this resource
	## currently in?
	##
	pgrepmgr_get_replication_status
	case $? in
	    $PGREPMGR_STATUS_IS_HOT_STANDBY)
		pgrepmgr_cib_status "HOT STANDBY"
		ocf_log info "$RESOURCE monitor: instance is HOT STANDBY"
		;;
	    $PGREPMGR_STATUS_IS_PRIMARY)
		pgrepmgr_status "PRIMARY"
		ocf_log info "$RESOURCE monitor: instance is PRIMARY"
		;;
	    *)
		## oops
		pgrepmgr_cib_status "STOP:unknown state"
		ocf_log info "$RESOURCE monitor: unknown state $*"
		return $OCF_ERR_GENERIC
	esac

    fi

    return $OCF_SUCCESS
}

pgrepmgr_promote() {

    if ! pgrepmgr_status; then
	ocf_log err "PostgreSQL not running"
	pgrepmgr_cib_status "STOP:Instance not running"
	return $OCF_NOT_RUNNING

    else

	## Not running in recovery mode indicates primary node
	if [[ ! -f $OCF_RESKEY_pgdata/recovery.conf 
		    && pg_get_replication_status -eq PGREPMGR_STATUS_PRIMARY ]]; then

	    ocf_log info "$RESOURCE promote: Already primary"
	    pgrepmgr_cib_status "PRIMARY"
	    return $OCF_SUCCESS

	else
	    local RC

	    ## An existing recovery.conf tells us, that this
	    ## node is a standby and we want to promote it to a primary.
	    ## Call repmgr to activate it.
	    ocf_log info "Standby about to activated as primary node"
	    runasowner ${OCF_RESKEY_repmgrbin}/repmgr -f ${OCF_RESKEY_repmgr_config} standby promote
	    RC=$?

	    if [[ $RC -ne 0 ]]; then
		ocf_log err "$RESOURCE promote: error promoting instance"
		pgrepmgr_cib_status "ERR:failed to promote"
		RC=$OCF_ERR_GENERIC
	    else
		ocf_log info "Standby promoted to primary"
		pgrepmgr_cib_status "PRIMARY"
		RC=$OCF_SUCCESS
	    fi

	    return $RC
	fi

    fi

}

pgrepmgr_demote() {
    return $OCF_SUCCESS
}

pgrepmgr_cib_status() {
    return $OCF_SUCCESS
}

pgrepmgr_validate_all() {
    return $OCF_SUCCESS
}

#
#   'main' starts here...
#


if [ $# -ne 1 ]
then
    usage
    exit $OCF_ERR_GENERIC
fi

case "$1" in
    methods)    pgrepmgr_methods
                exit $?;;
		
    meta-data)  meta_data
                exit $OCF_SUCCESS;;

    validate-all) pgrepmgr_validate_all
                exit $?;;
esac

if ! pgrepmgr_validate_all
then
    case "$1" in
        stop)    exit $OCF_SUCCESS;;
        monitor) exit $OCF_NOT_RUNNING;;
        status)  exit $OCF_NOT_RUNNING;;
        *)       exit $OCF_ERR_INSTALLED;;
    esac
fi

US=`id -u -n`

if [ $US != root -a $US != "$OCF_RESKEY_resowner" ]
then
    ocf_log err "$0 must be run as root or $OCF_RESKEY_resowner"
    exit $OCF_ERR_GENERIC
fi

# What kind of method was invoked?
case "$1" in
    status)     if pgrepmgr_status
                then
                    ocf_log info "PGREPMGR is up"
		    if [[ pgrepmgr_get_replication_status -eq PGREPMGR_STATUS_IS_PRIMARY ]]; then
			ocf_log info "PGREPMGR PRIMARY"
		    else
			ocf_log info "PGREPMGR HOT STANDBY"
		    fi
                    exit $OCF_SUCCESS
                else
                    ocf_log info "PGREPMGR is down"
                    exit $OCF_NOT_RUNNING
                fi;;

    monitor)    pgrepmgr_monitor
                exit $?;;

    start)      pgrepmgr_start               
                exit $?;;

    promote)    pgrepmgr_promote
	        exit $?;;
    demote)     pgrepmgr_demote
	        exit $?;;
    stop)       pgrepmgr_stop
                exit $?;;
    *)
                exit $OCF_ERR_UNIMPLEMENTED;;
esac
