#!/bin/sh
#
# Description:  Manages a cluster service for PostgreSQL
#               streaming replication clusters
#
# Author:       Bernd Helmle (bernd.helmle@credativ.de)

# OCF parameters:
#
#     OCF_RESKEY_pgpidfile         - Path to the local PostgreSQL PID file
#     OCF_RESKEY_primary_db        - PostgreSQL primary database to connect to for CLONING
#     OCF_RESKEY_primary_host      - PostgreSQL primary ip address to connect for CLONING
#     OCF_RESKEY_primary_port      - PostgreSQL primary port to connect to for CLONING
#     OCF_RESKEY_primary_user      - PostgreSQL primary user to connect as for CLONING
#     OCF_RESKEY_pgdata            - Path to the local PGDATA directory
#     OCF_RESKEY_rsync_user        - Rsync user name to use for repmgr during CLONING
#     OCF_RESKEY_resowner          - Resource owner (default 'postgres')
#     OCF_RESKEY_wal_keep_segments - Forced number of WALs to keep (GUC wal_keep_segments)
#     OCF_RESKEY_repmgr_config     - Full path to the repmgr configuration file
#     OCF_RESKEY_pgctl             - Full path to pg_ctl binary of the local PostgreSQL instance
#     OCF_RESKEY_repmgrbindir      - Full path to repmgr binary. This is also where we assume
#                                    where the repmgrd binary resides.
#     OCF_RESKEY_psqlbin           - psql binary location (full path)

: ${OCF_FUNCTIONS_DIR=${OCF_ROOT}/resource.d/heartbeat}
. ${OCF_FUNCTIONS_DIR}/.ocf-shellfuncs

unset LC_ALL; export LC_ALL
unset LANGUAGE; export LANGUAGE

usage() {

    cat<<EOF

	usage: $0 start|stop|status|monitor|meta-data|validate-all|methods

	$0 manages a PostgreSQL Server as an HA resource.

         The 'start' operation starts the PostgreSQL server.
         The 'stop' operation stops the PostgreSQL server.
         The 'status' operation reports whether the PostgreSQL is up.
         The 'monitor' operation reports whether the PostgreSQL is running.
         The 'promote' operation delegates primary role to the PostgreSQL instance
         The 'demote' operation makes a PostgreSQL instance to a standby
         The 'validate-all' operation reports whether the parameters are valid.
         The 'methods' operation reports on the methods $0 supports.

EOF
  return $OCF_ERR_ARGS
}

meta_data() {
cat <<EOF
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="pgrepmgr">
<version>1.0</version>

<longdesc lang="en">
Resource script for PostgreSQL Streaming Replication Clusters.
</longdesc>
<shortdesc lang="en">Manages a PostgreSQL Streaming Replication Cluster</shortdesc>

</resource-agent>
EOF

exit $OCF_SUCCESS
}

##
## Run the given command string in the resource owner environment
##
runasowner() {
    su $OCF_RESKEY_resowner -c "$*"
}

##
## Which methods are supported by this resource agent?
pgrepmgr_methods() {
    cat <<EOF
	start
	stop
	status
	demote
	promote
	monitor
	notify
	methods
	meta-data
	validate-all
EOF
    return $OCF_SUCCESS
}

pgrepmgr_start() {

    return pgrepmgr_status

}

pgrepmgr_stop() {

    ## If the current node is a standby, shut down
    ## repmgrd

    return $OCF_SUCCESS

}

#
# pgsql_status: is PostgreSQL up?
#

pgrepmgr_status() {
     if [ -f $PIDFILE ]
     then
         PID=`head -n 1 $PIDFILE`
         kill -0 $PID >/dev/null 2>&1 && fuser $OCF_RESKEY_pgdata 2>&1 | grep $PID >/dev/null 2>&1
         return $?
     fi

     # No PID file
     false
}

##
## Checks wether the current PostgreSQL node is running
## as a primary or hot standby instance
##
pgrepmgr_get_replication_status() {

    if $(runasowner "$PSQLCMD 'SELECT pg_is_in_recovery();'") = 'f'; then
	return $PGREPMGR_STATUS_IS_HOT_STANDBY
    fi

    return $PGREPMGR_STATUS_IS_PRIMARY

}

## Monitor PostgreSQL instance. Since repmgr is depending on a running
## PostgreSQL instance, make sure it is running
pgrepmgr_monitor() {

    ## We need to be careful with monitor probes against this resource

    if ! ocf_is_probe; then

	if ! pgsql_status; then
	    ocf_log warn "$RESOURCE monitor: PostgreSQL not running"
	    pgrepmgr_cib_status "STOP:not running"
	    return $OCF_NOT_RUNNING
	fi

    else

	## check wether any action is in progress
	
	## While this RA is running it might occur that syncing during
	## a demote phase could have a very long duration. Check for a
	## in-progress clone phase.
	if [ -f $CLONE_LOCK ]; then
	    $ATTRD_UPDATER -n $PGREPMGR_STATUS_NAME -v "STOP:waiting for promote"
	    return $OCF_SUCCESS
	fi

	if ! pgsql_status; then
	    ocf_log warn "$RESOURCE monitor: PostgreSQL not running"
	    pgrepmgr_cib_status "STOP:not running"
	    return $OCF_NOT_RUNNING
	fi

	##
	## Not CLONE_LOCK file found, what role is this resource
	## currently in?
	##
	case pgrepmgr_get_replication_status in
	    PGREPMGR_STATUS_IS_HOT_STANDBY)
		pgrepmgr_cib_status "HOT STANDBY"
		;;
	    PGREPMGR_STATUS_IS_PRIMARY)
		pgrepmgr_status "PRIMARY"
		;;
	    *)
		## oops
		pgrepmgr_cib_status "STOP:unknown state"
		return $OCF_ERR_GENERIC
	esac

    fi

    return $OCF_SUCCESS
}

pgrepmgr_promote() {

    if ! pgrepmgr; then
	ocf_log err "PostgreSQL not running"
	pgrepmgr_cib_status "STOP:Instance not running"
	return $OCF_NOT_RUNNING

    else

	## Not running in recovery mode indicates primary node
	if [[ ! -f $OCF_RESKEY_pgdata/recovery.conf 
		    && pg_get_replication_status -eq PGREPMGR_STATUS_PRIMARY ]]; then

	    ocf_log info "$RESOURCE promote: Already primary"
	    pgrepmgr_cib_status "PRIMARY"
	    return $OCF_SUCCESS

	else
	    local RC

	    ## An existing recovery.conf tells us, that this
	    ## node is a standby and we want to promote it to a primary.
	    ## Call repmgr to activate it.
	    ocf_log info "Standby about to activated as primary node"
	    ${OCF_RESKEY_repmgrbin}/repmgr -f ${OCF_RESKEY_repmgr_config} standby promote
	    RC=$?

	    if [[ $RC -ne 0 ]]; then
		ocf_log err "$RESOURCE promote: error promoting instance"
		pgrepmgr_cib_status "ERR:failed to promote"
		RC=$OCF_ERR_GENERIC
	    else
		ocf_log info "Standby promoted to primary"
		pgrepmgr_cib_status "PRIMARY"
		RC=$OCF_SUCCESS
	    fi

	    return $RC
	fi

    fi

}

pgrepmgr_demote() {

    if ! pgrepmgr_status; then

	ocf_log err "Instance not running"
	pgrepmgr_cib_status "STOP:instance not running"
	return $OCF_NOT_RUNNING

    fi

    ## Check wether this node is a primary instance
    if [[ pg_replication_get_status -eq PGREPMGR_STATUS_HOT_STANDBY ]]; then

	ocf_log info "Instance is a standby already"
	pgrepmgr_cib_status "START:instance is standby"
	return $OCF_SUCCESS

    else

	## OK, now comes the tricky part. This is a primary instance, and we want to
	## demote it to a standby. This requires us to build the standby from scratch.
	## Since this could be a long operation, we need to take care.
	if [[ ! touch $CLONE_LOCK ]]; then
	    ocf_log err "Could not create file \"${CLONE_LOCK}\""
	    return $OCF_ERR_GENERIC
	fi

	## First, shut the server down, if not already done
	if pgrepmgr_status ; then

	    ocf_log debug "Shutting down PRIMARY"
	    runasowner $OCF_RESKEY_pgctl -D $OCF_RESKEY_pgdata -m fast stop

	    ## still alive?
	    if [[ pgrepmgr_status ]]; then

		ocf_log debug "Shutting PRIMARY not succeeded, retry with immediate shutdown"

		## oops, something is weird, maybe instance hangs somewhere,
		## try to make it the hard way...
		runasowner $OCF_RESKEY_pgctl -D $OCF_RESKEY_pgdata -m immediate stop

		## Wait
		count=0
		while [ $count -lt $OCF_RESKEY_stop_escalate ]
		do

		    if ! pgrepmgr_status; then
			# success
			break;
		    fi
		    count = $(expr $count + 1)
		    sleep 1

		done

	    fi

	    if pgrepmgr_status; then
		## hmm okay, something really weird is going on,
		## exit immediately
		ocf_log err "An fatal error occured: instance is not shutting down"
		pgrepmgr_cib_status "ERROR:instance not shutting down"
		rm -f $CLONE_LOCK
		return $OCF_ERR_GENERIC
	    else
		ocf_log "Shutdown immediate succeeded"
	    fi

	fi

	## If reached here, PGSQL has successfully shut down, proceed:
	## First, we need to make sure the old PGDATA isn't present anymore
	ocf_log debug "Dropping $OCF_RESKEY_pgdata"

	## if ${OCF_RESKEY_pgdata} doesn't exist yet, nothing to do here.
	## Otherwise we need to get rid of it, because we are forced
	## to resync with the primary node. This is a very destructive
	## task to do, so do some preliminary checks before.
	if [[ -d ${OCF_RESKEY_pgdata} ]]; then

	    ## TODO: Much more checks here...

	    if ! rm -rf ${OCF_RESKEY_pgdata} ; then
		ocf_log err "Could not delete cluster directory \"${OCF_RESKEY_pgdata}\""
		rm -f $CLONE_LOCK
		return $OCF_ERR_GENERIC
	    fi

	fi

	local FIN_RC=$OCF_ERR_GENERIC

        ## Clone the current master
	${OCF_RESKEY_repmgrbindir}/repmgr -U${OCF_RESKEY_primary_user} \
	    -d${OCF_RESKEY_primary_db -p${OCF_RESKEY_primary_port} \
	    standby clone ${OCF_RESKEY_primary_host};

	RC=$?

	## Handle error cases of repmgr and issue specific
	## error messages

	if [[ $RC -ne 0 ]]; then

	    case $RC in
		1) 
		    ocf_log err "$RESOURCE demote: bad repmgr config"
		    ;;
		2)
		    ocf_log err "$RESOURCE demote: rsync error"
		    ;;
		3)
		    ocf_log err "$RESOURCE demote: pg_stop_backup() failed"
		    ;;
		5)
		    ocf_log err "$RESOURCE demote: needs xlog"
		    ;;
		*)
		    ocf_log err "$RESOURCE demote: failed to clone standby"
		    ;;
	    esac

	    pgrepmgr_cib_status "ERROR:standby demote failed"

	    ## an error has occured, cleanup
	    rm -f $CLONE_LOCK
	    return $OCF_ERR_GENERIC

	else

	    ocf_log info "STANDBY CLONE ok"
	    ocf_log debug "Starting new standby"

	    ## Now start the new standby
	    runasowner ${OCF_RESKEY_pgctl} -D ${OCF_RESKEY_pgdata} start
	    RC=$?

	    if [[ $RC -eq 0 ]]; then

		ocf_log debug "Standby instance started"
		pgrepmgr_cib_status "STANDBY:instance standby"
		rm -f $CLONE_LOCK
		return $OCF_SUCCESS

	    else

		ocf_log err "Standby instance could not be started"
		rm -rf $CLONE_LOCK
		return $OCF_NOT_RUNNING

	    fi

	fi

    fi

}

pgrepmgr_cib_status() {
    $ATTRD_UPDATER -n $PGREPMGR_STATUS_NAME -v "$*"    
}

## Check given runtime parameters
pgrepmgr_validate_all() {

    return $OCF_SUCCESS

}

#
#   'main' starts here...
#


if [ $# -ne 1 ]
then
    usage
    exit $OCF_ERR_GENERIC
fi

: ${OCF_RESKEY_repmgr_conf="/etc/repmgr.conf"}
: ${OCF_RESKEY_stop_escalate=30}

##
## Internal resource parameters
##

PIDFILE="${OCF_RESKEY_pgdata}/postmaster.pid"
BACKUPLABEL="${OCF_RESKEY_pgdata}/backup_label"
ATTRD_UPDATER="${HA_SBIN_DIR}/attrd_updater -q -d 0"
PGREPMGR_STATUS_NAME="pgrepmgr-status"
CLONE_LOCK="${OCF_RESKEY_tmpdir}/PGSQL.${OCF_RESKEY_primary_host}.${OCF_RESKEY_primary_port}.clone"
PSQLCMD="/usr/bin/psql -qXtnAc -v ON_ERROR_STOP=1"

##
## Internal status codes
##
PGREPMGR_STATUS_IS_PRIMARY=0
PGREPMGR_STATUS_IS_HOTSTANDBY=1

case "$1" in
    methods)    pgrepmgr_methods
                exit $?;;
		
    meta-data)  meta_data
                exit $OCF_SUCCESS;;

    validate-all) pgrepmgr_validate_all
                exit $?;;
esac

if ! pgrepmgr_validate_all
then
    case "$1" in
        stop)    exit $OCF_SUCCESS;;
        monitor) exit $OCF_NOT_RUNNING;;
        status)  exit $OCF_NOT_RUNNING;;
        *)       exit $OCF_ERR_INSTALLED;;
    esac
fi

US=`id -u -n`

if [ $US != root -a $US != $OCF_RESKEY_resowner ]
then
    ocf_log err "$0 must be run as root or $OCF_RESKEY_resowner"
    exit $OCF_ERR_GENERIC
fi

# What kind of method was invoked?
case "$1" in
    status)     if pgrepmgr_status
                then
                    ocf_log info "PGREPMGR is up"
                    exit $OCF_SUCCESS
                else
                    ocf_log info "PGREPMGR is down"
                    exit $OCF_NOT_RUNNING
                fi;;

    monitor)    pgrepmgr_monitor
                exit $?;;

    start)      pgrepmgr_start               
                exit $?;;

    promote)    pgrepmgr_promote
	        exit $?;;
    demote)     pgrepmgr_demote
	        exit $?;;
    stop)       pgrepmgr_stop
                exit $?;;
    *)
                exit $OCF_ERR_UNIMPLEMENTED;;
esac
